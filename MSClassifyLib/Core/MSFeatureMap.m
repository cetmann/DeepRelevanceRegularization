classdef MSFeatureMap < matlab.mixin.Copyable
  % Abstract base class for feature map classes
  % 
  % This class is an abstract base class for feature map classes that map
  % spectra to feature vectors. A derived feature map has to define the
  % map() method that computes the output feature vector from an input data
  % object. Moreover, a derived feature map shall define a unique creator
  % string that will be stored in output feature maps as an indication of
  % how the respective feature data was generated.
  %
  % Properties:
  %   creator: Feature map creator, stored in data created by this map
  %   mzVector: mzVector of input data in map
  %   numFeatures: Number of output features
  %   featureMapInfo: Struct for arbitrary feature map information
  %
  % Methods:
  %   MSFeatureMap: Constructor
  %   map: Compute output feature data from input data. Uses the abstract 
  %   map_impl(abstract): map implementation
  %   getNumFeatures(abstract): Gets number of features property
  %   show: Shows graphic representation of the map
  %
  % MSFeatureMap uses the handle semantic, i.e. when assigning an object
  % of this class to a variable, only a reference to the original object is
  % copied. Use the copy method to create a deep copy.
  
  properties (SetAccess = immutable)
      creator  % Feature map creator, stored in feature data created by this map 
      mzVector % mzVector of expected input data items in map
      numFeaturesIn
  end
  
  properties (Dependent)
      numFeatures %Output number of features
  end
  
  properties
      featureMapInfo = struct; % Struct for arbitrary feature map information
      additionalFeatureMaps = {};
  end

  methods
    function obj = MSFeatureMap (mzVector, creator, numFeaturesIn)
      % Constructor
      % obj = MSFeatureMap(mzVector): Create a feature map expecting input
      %   data with an mz vector as specified
      % obj = MSFeatureMap(__, creator): Additionally specify the feature
      %   map's creator string. The creator string is stored in feature
      %   data objects generated by this map.
      narginchk(1,3)
      if nargin < 2
        creator = '';
      elseif ~ischar(creator)
        error('creator must be either empty or a string');
      end
      obj.creator = creator;
      
      if nargin > 2
        obj.numFeaturesIn = numFeaturesIn;
        obj.mzVector = [];
      else
        if ~isnumeric(mzVector) || isempty(mzVector) || ~isvector(mzVector)
            error('mzVector must be a numeric non-empty vector');
        end
        v=unique(mzVector);
        obj.mzVector=v(:)';
        obj.numFeaturesIn = length( obj.mzVector );
      end
    end
    
    function featureData = map(obj, msData, itemMask, numFeatures, printFlag)
        % Creates an MSFeatureData
        % featureData = map(obj, msData, itemMask, numFeatures)       
        % INPUT
        %  msData: MSData object to which the mapping is applied
        %  itemMask: logical mask specifying the spectra to which the mapping
        %            is applied
        %  numFeatures: Restrict the output number of features to the
        %            specified quantity
        % OUTPUT
        %  featureData: MSFeatureData object.
        
        % Input validation
        narginchk(2,5);
        if nargin < 5
          printFlag = false;
        end
        if ~isempty( obj.mzVector )
          %check maldi data
          if ~isa(msData, 'MSMaldiData')
              error('Input argument must be an MSMaldiData object')
          end
          msData.assert;
          if length(msData.mzVector)~=length(obj.mzVector) || any(obj.mzVector ~= msData.mzVector)
             error('mzVector of input data and feature map object must be the same')
          end
          %check numFeatures
          if nargin < 4 || isempty(numFeatures) 
              numFeatures=obj.numFeatures;
          elseif ~(isnumeric(numFeatures)&& isscalar(numFeatures)&& numFeatures>0)
              error('numFeatures must be a positive scalar')
          elseif numFeatures>obj.numFeatures
              warning(['The requested number of features exceeds the maximum'...
                     'number of features. Only %d features will be extracted'], obj.numFeatures);
              numFeatures=obj.numFeatures;
          end
        else
          if msData.dataLength ~= obj.numFeaturesIn
             error('dimension of input data and feature map object must be the same')
          end
        end  
        
        if nargin < 4 || isempty(numFeatures) 
              numFeatures=obj.numFeatures;
        end
        
        %check itemMask
        if nargin<3||isempty(itemMask)
            itemMask=true(msData.numItems,1);
        else
            if isa(itemMask,'MSLabelData')
                itemMask=itemMask.data;
            end
            if isnumeric(itemMask)
                if any(size(itemMask)~=[msData.numItems, 1])
                    error('itemMask dimensions should be [%d,1] ', msData.numItems)
                else
                    itemMask=itemMask~=0;
                end
            elseif(~isempty(itemMask)&&(~islogical(itemMask)||~isvector(itemMask)...
                                      ||length(itemMask)~=msData.numItems))
                error('itemMask must be a logical array of dimension %d', msData.numItems)
            end
        end
        
        % Apply map and generate feature data
        featureData = obj.map_impl(msData, itemMask, numFeatures, printFlag);
        
        numAddD = length(msData.additionalDataVersions);
        numAddFM = length(obj.additionalFeatureMaps);
        if numAddD < numAddFM
            warning('Number of add. data versions lower than number of add. FMs');
        end
        
        for i = 1:min(numAddD,numAddFM)
            featureData.additionalDataVersions{i} = ...
                obj.additionalFeatureMaps{i}.map(msData.additionalDataVersions{i}, itemMask, [], printFlag);
            featureData.additionalDataVersions{i}.assert;
        end
        % Check consistency
        featureData.assert;
    end
    
    function N = get.numFeatures(obj)
        % get number of output features. The implementation must be defined
        % by the subclasses through the getNumFeatures method
        N=getNumFeatures(obj);
    end        
    
    function show(~, varargin)
        % Graphic representation of the map.
        % INPUT
        %   varargin: inputs specifying which representation is required
        disp('There is no implemented representation for the requested map')
    end
  end
      
  methods (Abstract, Access=protected)
      % map implementation
      featureData = map_impl (obj, msData, itemMask, numFeatures) 
      % implementation of numFeatures' property get
      numFeatures = getNumFeatures(obj)
  end
  
end

