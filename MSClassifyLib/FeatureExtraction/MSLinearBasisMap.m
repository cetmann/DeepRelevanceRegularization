classdef MSLinearBasisMap < MSFeatureMap
  % Feature map based on scalar products with basis vectors
  % 
  % This class is a simple feature map computing output features as scalar
  % products between input data items and basis vectors.
  %
  % Properties:
  %   basis:      Matrix of basis vectors
  %   sortInd: struct containing the already determined sortings (list of
  %     indices to resort basis for the criterion (fieldname), always
  %     assuming the current sorting would be in the initial sorting; the
  %     initial sorting (1:n)' is defined only in the constructor)
  %   sortTypeCurr: string defining the currently active sorting
  %     ('initial', 'l1l2', 'gini', 'rocMax' or 'rocMaxLabelBalance')
  %   sortTypes: cell array containing strings of already determined
  %     sortings
  %
  % Methods:
  %   MSLinearBasisMap: Constructor
  %   map_impl: Compute output feature data from input data
  %   sortBasisVectors: determine sorting for the chosen sortMethod, save
  %     the corresponding indexing as a field in the sortInd property
  %     ('initial' is only defined in the constructor; 'l1l2' and 'gini'
  %     are not labelData dependent and will only be calculated once; for
  %     each, 'rocMax' and 'rocMaxLabelBalance', only one field is reserved
  %     and it will be calculated new for every invocation of this method
  %     so that a sorting with new labelData will overwrite the old 
  %     indices), resort basis to the chosen sortMethod, change 
  %     sortTypeCurr prop to sortMethod; 
  %     in the featureMapInfo property additional information
  %     to the sortings can be found (l1l2norms, gini-indices,
  %     rocMax-values and rocMaxLabelBalance matrix (one column for every
  %     label if there are more than two labels))
  %   calcAllSortings: determine all sortings (and resort to current
  %     sorting)
  %   listSortings: show the (so far determined) sortings in the sortInd
  %     property in a table, can be restricted to certain rows in an
  %     (optional) input argument
  %
  % MSLinearBasisMap uses the handle semantic, i.e. when assigning an object
  % of this class to a variable, only a reference to the original object is
  % copied. Use the copy method to create a deep copy.
  %
  %
  %
  
  properties (SetAccess = protected)
    basis      % Matrix of basis vectors
    sortInd = struct; % different sortings of basis vectors
    sortTypeCurr = 'initial'; % current sorting type
  end
  
  properties (Dependent)
    sortTypes % List of available sortings
  end
  
  methods
    function obj = MSLinearBasisMap (mzVector, basis, creator)
      % Constructor
      % obj = MSLinearBasisMap(basis, creator)
      %   basis: Basis vectors used for computing scalar products with
      %     input data
      %   creator: Feature map creator string (optional, defaults to 
      %     MSLinearBasisMap)
      
      narginchk(2,3);
      if nargin < 3
        % If creator string is not specified, use this class name
        creator = 'MSLinearBasisMap';
      end
      % Initialize feature map
      obj@MSFeatureMap(mzVector, creator);
      % Check input arguments
      if isempty(basis) || ~isnumeric(basis) || ~ismatrix(basis)
        error('basis must be a non-empty numeric matrix');
      end  
      if size(basis,2)~=length(obj.mzVector)
          error(['the number of columns of basis and the number'...
                 'of elements of mzVector must be the same'])
      end
      obj.basis = basis;
      obj.sortInd.initial = (1:size(basis,1))';
    end
        
    function T = get.sortTypes (obj)
      % Get sorting types
      T = fieldnames(obj.sortInd);
    end  

    
    function sortBasisVectors(obj,sortMethod,msData,labelData)
      % Sort basis vectors according to a criterion (sortMethod)
      %   sortMethod: 'l1l2' or 'gini' (in those cases the only input!), 
      %         'rocMax' or 'rocMaxLabelBalance'
      %   msData/labelData: MSData/MSLabelData objects for resorting when
      %         using 'rocMax' or 'rocMaxLabelBalance'
      % l1l2: l1 over l2 norm to prefer sparse patterns first
      % gini: gini index to prefer sparse patterns first
      % rocMax: calculating roc values on feature data (generated by the
      %     basis) for all single labels in labeldata vs the complement,
      %     sorting by highest roc-value for any label
      % rocMaxLabelBalance: same as rocMax but additionally aiming to
      %     balance basis sorting with respect to label equalization, e.g.
      %     when 10 basis vectors, respectively the corresponding 
      %     featuredata, result in high roc-values for one label not all 10 
      %     are listed first because additional attention is payed to
      %     separate all existing labels from their complement well with
      %     the first n basis vectors (for all n)
      %
      % if rocMax or rocMaxLabelBalance is invoked sortInd.rocMax and
      % sortInd.rocMaxLabelBalance are determined both (later invocations
      % will always be freshly calculated to allow a change for new
      % labelData objects - it is not time consuming anyways)
      %
      % in the featureMapInfo property additional information
      % to the sortings can be found (l1l2norms, gini-indices,
      % rocMax-values and rocMaxLabelBalance matrix (one column for every
      % label if there are more than two labels))
      %
      
        % Check inputs
        if ~any(strcmp(sortMethod,{'initial','l1l2','gini','rocMax',...
                'rocMaxLabelBalance'}))
            error(['Unknown sortMethod. Available are ''initial',...
                ', ''l1l2'', ''gini'', ''rocMax'' and ',...
                'rocMaxLabelBalance''.']);            
        elseif nargin ~= (1+3) && ~any(strcmp(sortMethod,{'initial',...
                'l1l2','gini'}))
            error(['For other sortMethods than "initial", ''l1l2'' or ',...
                'gini'' 3','input arguments are expected']);
        elseif nargin>2
            if any(strcmp(sortMethod,{'initial','l1l2','gini'}))
              warning(['For the chosen sortMethod "%s" no additional ',...
                  'input arguments are expected! They will be ',...
                  'ignored.'],sortMethod);
            else
              if ~isa(msData,'MSData')
                  error('2nd input argument must be an MSData object');
              elseif ~(isa(labelData,'MSLabelData') || ...
                      (isnumeric(labelData) && ~isempty(labelData) && ...
                      isvector(labelData)))
                  error(['3rd input argument must be an MSLabelData ',...
                      'object or a numeric (label) vector']);
              end
            end     
        end
        
        % sort back to initial basis first!
        sort2Ini = MSResorter(obj.sortInd.(obj.sortTypeCurr),...
            obj.sortInd.initial);
        obj.basis = sort2Ini(obj.basis);
        obj.sortTypeCurr = 'initial';
     
        % check if already determined indices in the object can be used
        % (for roc based sortMethods indices are calculated in any case so 
        % that new label objects will overwrite the old fields)
        if any(strcmp(sortMethod,{'l1l2','gini'})) && any(...
                strcmp(sortMethod,obj.sortTypes))
            sortIndC = obj.sortInd.(sortMethod);
        else
          % determine indices to resort basis depending on chosen method
          switch sortMethod
              case 'initial'
                % don't do anything here
                sortIndC = obj.sortInd.initial;
              case 'l1l2'
                  l1norm = @(x)sum(abs(x),2);
                  l2norm = @(x)sqrt(sum(x.*x,2));
                  l1l2norm = @(x)l1norm(x)./l2norm(x);
                  coeffs = l1l2norm(obj.basis);
                  obj.featureMapInfo.l1l2Norms = coeffs;
                  [~,sortIndC] = sort(coeffs);
                  obj.sortInd.l1l2 = sortIndC;
              case 'gini'
                  l1norm = @(x)sum(abs(x),2);
                  giniSumCoeff = @(N,k)(N-k+0.5)/N; 
                  giniSum = @(C)sum(sort(abs(C),2).*...
                      repmat(giniSumCoeff(size(C,2),1:size(C,2)),...
                      size(C,1),1),2);
                  giniFun = @(x)1-2./l1norm(x).*giniSum(x);
                  coeffs = -giniFun(obj.basis);
                  obj.featureMapInfo.giniIndices = -coeffs;
                  [~,sortIndC] = sort(coeffs);
                  obj.sortInd.gini = sortIndC;
              case {'rocMax','rocMaxLabelBalance'}
                  featureData = MSData(msData.data*obj.basis');
                  [rankedList,rocMaxVals,rocValsTotal] = ...
                      MSROCRanking(featureData,labelData,inf,'true');
                  obj.sortInd.rocMax = rankedList.rocMax;
                  obj.sortInd.rocMaxLabelBalance = ...
                      rankedList.rocMaxLabelBalance;
                  obj.featureMapInfo.rocMaxVals = rocMaxVals;
                  obj.featureMapInfo.rocValsTotal = rocValsTotal;
                  switch sortMethod
                    case 'rocMax'
                      sortIndC = rankedList.rocMax;
                    case 'rocMaxLabelBalance'
                      sortIndC = rankedList.rocMaxLabelBalance;
                  end
          end
        end
        % resort basis vectors and change current sorting type
        obj.basis = obj.basis(sortIndC,:);
        obj.sortTypeCurr = sortMethod;
    end
    
    function calcAllSortings(obj,msData,labelData)
      % Determine all sortings, save them in the sortInd property and the
      % corresponding information in the featureMapInfo property, and
      % resort to the current sorting
      if ~isa(msData,'MSData')
          error('2nd input argument must be an MSData object');
      elseif ~isa(labelData,'MSLabelData') || (isnumeric(labelData) && ...
              ~isempty(labelData) && isvector(labelData))
          error(['3rd input argument must be an MSLabelData object ',...
              'or a numeric (label) vector']);
      end
      sortTypeCurrentSave = obj.sortTypeCurr;
      obj.sortBasisVectors('l1l2');
      obj.sortBasisVectors('gini');
      obj.sortBasisVectors('rocMax',msData,labelData);
      % (rocMaxLabelBalance sorting is calculated and saved on the way)
      switch sortTypeCurrentSave
        case {'initial','l1l2','gini'}
          obj.sortBasisVectors(sortTypeCurrentSave);
        case {'rocMax','rocMaxLabelBalance'}
          obj.sortBasisVectors(sortTypeCurrentSave,msData,labelData);
      end
    end

    function T = listSortings(obj,rows)
      % Show the table of currently available sortings, optionally limited
      % to the rows given in the (optional) input argument
      narginchk(1,2);
      T = struct2table(obj.sortInd);
      if nargin == 2
        T = T(rows,:);
      end
    end
    
    function compareSortings(obj,T2)
      % Visualize how many indices of the first k rows can be found in all
      % sortings (divided by number of so far occurring indices
      % (~numel(unique(M(1:k,:)))), linear line plot as a function of k)
      %
      % T2 (optional) is expected to be a cell array of strings defining
      % the sortMethods that will be compared, eg. 
      % T2 = {'initial', 'l1l2', 'gini', 'rocMax'}
      % 
      T = obj.sortTypes; % so far determined sort types
      if nargin == 1
        T2 = T;
        T2(strcmp(T2,'initial'))=[]; % by default not comparing with the
        % initial sorting if no input is given (still comparing it if it is
        % explicitely chosen as an input)
      end
      T2 = T2(:); % input sort types to compare (enforcing column cell
      %             array)
      TT = intersect(T,T2); % sort types that will be compared 
      %                     (if more than 1)
      if numel(TT) <= 1
        error(['The intersection of the input cell array and the ',...
          'available indSort fieldnames contains less than 2 elements ',...
          'such that a comparison is not possible. Possibly typos in ',...
          'the optional input argument or so far only the initial ',...
          'sorting has been defined or only one other sorting and the ',...
          'initial sorting is not used (default when not given as ',...
          'input string)! (use .sortBasisVectors or ,'...
          '.calcAllSortings)']);
      end
      if ~isempty(setdiff(T2,T))
        warning(['Some of the input sortTypes are unknown or not ', ... 
        'determined so far! (' strjoin(setdiff(T2,T)) ')']);
      end
      helperM = zeros(obj.numFeatures,numel(TT));
      for k = 1:numel(TT)
        helperM(:,k) = obj.sortInd.(TT{k});
      end
      numCombInd = zeros(obj.numFeatures,1);
      for k = 1:obj.numFeatures
        numCombInd(k) = numel(multiIntersect(helperM(1:k,:)))/...
        numel(unique(helperM(1:k,:))); % compare local function 
        %                                multiIntersect in this file
      end
      titleString = ['Comparing sortings ',strjoin(TT)];
      figure;
      plot(numCombInd);
      xlabel('The first k rows in the sortings are considered');
      ylabel('Percentage of common indices among the first k rows');
      title(titleString);
    end

  end
  
  methods (Access=protected)
      function featureData = map_impl (obj, msData, itemMask, numFeatures, ~)
      % Compute output feature data from input data
      % featureData = obj.map (msData)
      %   msData: MSMaldiData object with input data (spectra, feature vectors)
      %   featureData: Resulting MSFeatureData object with feature vectors
      %                consisting of scalar products between input data
      %                items and the map's basis vectors
      %   itemMask: logical mask specifying the spectra to which the mapping
      %             is applied
      %  numFeatures: Restrict the output number of features to the
      %               specified quantity
      
      % Create output feature data
      featureData = MSFeatureData(msData.data(itemMask,:) * obj.basis(1:numFeatures,:).', ...
          obj.creator);
      end
      
      function numFeatures = getNumFeatures (obj)
          numFeatures = size(obj.basis,1);
      end
  end
end


% local functions
function s = multiIntersect(M)
%iteratively using intersect on the columns of M

nCols = size(M,2);
if nCols == 1
  warning('multiIntersection applied to a 1 column matrix!');
else
  s = M(:,1);
  for k = 2:nCols
    s = intersect(s,M(:,k)); 
  end
end

end



